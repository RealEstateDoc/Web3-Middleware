pragma solidity ^0.4.23;
/* !!!! IMPORTANT NOTE !!!!!
This contract only for demo purpose, do not use it in production!
*/
//The latest version of contract deployed at
//https://rinkeby.etherscan.io/address/0x51000fee8980e0c82c32d12e04c2751f2cf35e3b

contract RedDemo {
    address owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    struct Contract{
        uint created_at;
        uint doc_id;
        uint trail_id;
        bytes32 hash_value;
    }

    // This array store the latest hash of each document , the key of of  array is the doc_id
    mapping (uint => bytes32) latest_hash;

    // This array store the data of contract
    mapping (bytes32 => Contract) contracts;

    event DocumentAdded(Contract theContract);

    event DocumentDuplicated(Contract existContract);

    // constructor and set owner by person who deployed the contract
    constructor() public {
        owner = msg.sender;
    }

    function getOwner() view public returns(address){
        return owner;
    }
    //  The function to store the document id , trail_id and hash value
    // The hash value generated by encode keccak256 of binary data of pdf file.

    function addDocument(uint _doc_id, uint _trail_id, bytes32 _hash)  external onlyOwner returns (bool)  {

        // make sure the hash is not submitted before
        if(contracts[_hash].doc_id == 0) {
            // create a contract record
            Contract memory aContract = Contract(now,_doc_id,_trail_id,_hash);
            // store into contract
            contracts[_hash] = aContract;

            // update the latest _hash
            latest_hash[_doc_id] = _hash;

            //
            emit  DocumentAdded(aContract);

            // return true , store success
            return true;
        }else{
            // the hash already exist, do not allow for overwrite
            // It will not return in this kind of function, so consider to use event to log the result, also
            Contract memory existContract = contracts[_hash];
            emit DocumentDuplicated(existContract);
            return false;
        }
    }

    // This function check if a hash is exist in blockchain
    function checkDocumentByHash(bytes32 _hash) view public returns (bool)  {
        // If has data contracts[_hash], it mean the hash stored
        return contracts[_hash].hash_value == _hash;
    }

    // This function check if a hash is exist in blockchain
    function isLatestHash(bytes32 _hash) view public returns (bool)  {
        //get the doc id , and check in latest hash that stored in latest hash arrays
        return latest_hash[contracts[_hash].doc_id] == _hash;
    }

    // The function return the data of hash that stored in blockchain, It return 4th parameter that say the hash is latest or not
    function getDocumentByHash(bytes32 _hash) view public
        returns (
            uint created_at,
            uint doc_id,
            uint trail_id,
            bytes32 hash_value,
            bool isLatest
        ){
        // check if document exist
        if(contracts[_hash].doc_id == 0) revert();

        Contract memory theContract = contracts[_hash];

        // The function return the data of hash that stored in blockchain, It return 4th parameter that say the hash is latest or not
        return(
            theContract.created_at,
            theContract.doc_id,
            theContract.trail_id,
            theContract.hash_value,
            latest_hash[theContract.doc_id] == _hash
        );

    }
}